'use strict';
var models = require('../models');
var utils = require('./utils');
var items = require('./items');

var pathJS = require('path');
//var itemList = new items();
var fs = require('fs');
var fileTypes = '';
var basePath = '';

/*
    * Checks wether file extension matches allowed ones
    * ext = extension
*/
//TODO: change file extensions to mime types
function checkType(ext) {
    let found = false;
    for (let i in fileTypes) {
        if (fileTypes[i] === ext) {
            found = true;
            break;
        }
    }
    return found;
}

/*
    * Deletes items from database which cannot be found in directory structure
*/
function deleteMissingItems(itemList) {
    return new Promise(function (resolve, reject) {
        if (itemList.items.length > 0) {
            for (let i in itemList.items) {
                models.items.destroy({ where: { id: itemList.items[i].id }, limit: 1 });
            }
            itemList.items.length = 0;
            resolve(true);
        }
        else {
            resolve(false);
        }
    });
}

/*
    * Fills item list with items from database
*/
function init(uid) {
    return new Promise(function (resolve, reject) {
        utils.getPath(uid).then(function (data) {
            basePath = data;
        }).catch(function (params) {
            console.log("getpath error: " + params);
            reject(params);
        });
        utils.getTypes().then(function (data) {
            fileTypes = data;
           
        }).catch(function (params) {
            console.log("gettypes error: " + params);
            reject(params);
        });
        resolve(true);
    });
}

//TODO: Comment
/*
    * Fills Item List array with items from database
*/
//FIXME: use users_data table instead of items  
//FIXME: get user dirs and make multiple itemlists for every dir
function fillItemList() {
    return new Promise(function (resolve, reject) {
        var itemList = new items();
        models.items.findAll().then(function (allitems) {
            allitems.map(function (obj) {
                itemList.addItem({ path: obj.path, id: obj.id });
            });            
            resolve(itemList);
        }).catch(function (err) {
            reject(err);
        });
    });
}

/*
    * Reads directory
    * path     = path to directory
    * level    = parent id in database (0 for first call)
    * itemList = list of items in db (generated by fillItemList)
    * upid     = id of folder from users_settings
    * uid      = user id
    * udid     = user_data id
*/
function readDir(path, level, itemList, upid, uid, udid) {
    var folderArray = Array();
    return new Promise(function (resolve, reject) {
        path = path.concat(pathJS.sep);
        var cycle = new Promise(function (resolve, reject) {
            fs.stat(path, function(err, stats) {
                if(err !== null) {
                    reject(err);
                }
                let data = fs.readdirSync(path);
                for (let i in data) {
                    let newPath = path.concat(data[i]);
                
                    try {
                        let stats = fs.statSync(newPath);
                        //var newlevel = 0;
                        if (stats.isDirectory()) {
                            itemList.removeItem({ path: newPath }).then(function (msg) {
                                //TODO: test if udid is good
                                folderArray.push(readDir(newPath, parseInt(msg), itemList, upid, uid, udid));
                            }).catch(function (msg) {

                                models.items.create({ name: data[i], parent: level, type: 0, path: newPath, upid: upid }).then(function (createditem) {
                                    let newlevel = createditem.id;
                                    
                                    /*if(level > 0) {
                                        models.users_data.find({where: {item: level}}).then(function (data2) {
                                            //TODO: remove this cond
                                            if(data2 === null) {
                                                console.log("users_data item with id " + level + " does not exist ! (1)");
                                            }
                                            else {
                                                models.users_data.create({ user: uid, data: data[i], item: newlevel, seen: 0, deleted: 0, parent: data2.id, type: 0 });
                                            }
                                        });
                                    }
                                    else {
                                        models.users_data.create({ user: uid, data: data[i], item: newlevel, seen: 0, deleted: 0, parent: 0, type: 0 });
                                    }*/
                                    models.users_data.create({ user: uid, data: data[i], item: newlevel, seen: 0, deleted: 0, parent: udid, type: 0 })
                                    .then(function (createditem2) {
                                        folderArray.push(readDir(newPath, newlevel, itemList, upid, uid, createditem2.id));
                                    });
                                    //let newudid = 0;
                                    
                                });
                                //TODO: create users_data item here, find parent from users_data
                            });
                        } else {
                            if (checkType(utils.fixExtension(data[i]))) {
                                itemList.removeItem({ path: newPath }).catch(function (msg) {
                                    let tmp = pathJS.parse(data[i]);
                                    //let newlevel = 0;
                                    models.items.create({ name: tmp.name, parent: level, type: 1, path: newPath, upid: upid }).then(function (createditem) {
                                        let newlevel = createditem.id;
                                        /*if(level > 0) {
                                            models.users_data.find({where: {item: level}}).then(function (data2) {
                                                if(data2 === null) {
                                                    console.log("users_data item with id " + level + " does not exist ! (2)");
                                                }
                                                else {
                                                    models.users_data.create({ user: uid, data: data[i], item: newlevel, seen: 0, deleted: 0, parent: data2.id, type: 1 });
                                                }
                                            });
                                        }
                                        else {
                                            models.users_data.create({ user: uid, data: data[i], item: newlevel, seen: 0, deleted: 0, parent: 0, type: 1 });
                                        }*/
                                        models.users_data.create({ user: uid, data: data[i], item: newlevel, seen: 0, deleted: 0, parent: udid, type: 1 });
                                    });
                                    
                                    //TODO: create users_data item here, find parent from users_data
                                });
                            }
                        }
                    } catch (err) {
                        //TODO: Change to something formal
                        console.log("tikriausiai dir eroras = " + err);
                    }
                }
                resolve(true);
            });
        });
        
        cycle.then(function (tmp) {
            if (folderArray.length > 0) {
                Promise.all(folderArray).then(function (data) {
                    resolve(itemList);
                }).catch(function (err) {
                    console.log(err);
                });
            } else {
                resolve(itemList);
            }
        });
    });
}

/*
    * Public method to initiate scan, returns integer:
    *   -1 if failed
    *    0 if nothing was changed
    *    x number of items deleted
*/
//TODO: create counter for added items and return it from readdir
function scan(uid) {
    return new Promise(function (resolve, reject) {
        init(uid).then(function () {
            fillItemList().then(function (itemList) {
                let promiseArray = Array();
                for(let i in basePath) {
                    promiseArray.push(readDir(basePath[i].path, 0, itemList, basePath[i].id, uid, 0));
                }

                Promise.all(promiseArray).then(function (data) {
                    
                    let ret = 0;
                    for (let i in data) {
                        if (data[i].items.length > 0) {
                            deleteMissingItems(data[i]).then(function (returned) {
                                if (returned) {
                                    ret += data[i].items.length;
                                } else {
                                    reject("Failed to delete " + data[i].items.length + " items.");
                                }
                            });
                        }
                    }
                    resolve(ret);
                }).catch(function (err) {
                    console.log("scan = " + err);
                    reject(err);
                });
            }).catch(function (err) {
                console.log("Failed scandir: " + err);
                reject(err);
            });
        });
    });
}

//TODO: remove
function scanitems(uid) {
    return new Promise(function (resolve, reject) {
        //TODO: implement me
        for(let i in basePath) {
            models.items.findAll({where: {upid: basePath[i].id}, order: 'type ASC'}).then(function (data) {
                if(data === null) {
                    resolve(0);
                }
                for(let j in data) {
                    models.users_data.find({where: {item: data[j].id}}).then(function (data2) {
                        if(data2 === null) {
                            //console.log("Item " + data[j].id +" not found.");
                            //TODO: SEARCH FOR PARENT IF parent > 0 !
                            if(data[j].parent > 0) {
                                models.users_data.find({where: {item: data[j].parent}}).then(function (data3) {
                                    
                                    if(data3 === null) {
                                        console.log("parent item with id " + data[j].parent + " not found !");
                                        reject("erorcik LOL");
                                        //models.users_data.create({ user: uid, item: data3.id, seen: 0, deleted: 0, parent: data3.parent, type: data[j].type });
                                    }
                                    else {
                                        //console.log(data3);
                                        models.users_data.create({ user: uid, data: data[j].name, item: data[j].id, seen: 0, deleted: 0, parent: data3.parent, type: data[j].type });
                                    }


                                });
                            }
                            else {
                                models.users_data.create({ user: uid, data: data[j].name, item: data[j].id, seen: 0, deleted: 0, parent: 0, type: data[j].type });
                            }
                            
                            //TODO: Create item
                        }


                    }).catch(function (err) {
                        console.log("users_data catch: " + err);
                    });
                }
                

            }).catch(function (err) {
                console.log("items.findall catch: " + err);
            });
        }
        
        resolve(true);
    });
}

function dirscan(uid) {
    return new Promise(function (resolve, reject) {
        scan(uid).then(function (params) {
            console.log("scan result = " + params);
            resolve(true);
            /*scanitems(uid).then(function (params) {
                resolve(true);
            }).catch(function (params) {
                console.log("scanitems error: " + params);
                reject(false);
            });*/
        }).catch(function (params) {
            console.log("dirscan error: " + params);
            reject(false);
        });
    });
}

exports.dirscan = dirscan;
//exports.scan = scan;