'use strict';
var models = require('../models');
var utils = require('./utils');
var items = require('./items');

var pathJS = require('path');
var fs = require('fs');
var mime = require('mime');

/*
    * Checks wether file has mime type of video/<type>
    * file = File to check
*/
function isVideo(file) {
    let type = mime.lookup(file);
    let leftSide = type.split('/');
    if(leftSide[0] === "video") {
        return true;
    }
    return false;
}

/*
    * Checks wether file has the required mime type
    * file = File to check
*/
function isSubtitle(file) {
    let type = pathJS.extname(file).substring(1);
    let mimeArray = ['srt', 'ssa', 'ass', 'smi', 'sub', 'idx', 'mpl',
        'vtt', 'psb', 'sami', 'pjs'];

    if(mimeArray.indexOf(type) > -1) {
        return true;
    }
    return false;
}

/*
    * Deletes items from database table items and users_data which cannot be found in directory structure
    * uid      = User id
    * itemList = List of items
*/
function deleteMissingItems(uid, itemList) {
    return new Promise(function (resolve, reject) {
        if (itemList.items.length > 0) {
            for (let i in itemList.items) {
                models.physical_items.destroy({ where: { id: itemList.items[i].id }, limit: 1 });
                models.virtual_items.destroy({ where: { iid: itemList.items[i].id, uid: uid}, limit: 1 });
            }
            itemList.items.length = 0;
            resolve(true);
        }
        else {
            resolve(false);
        }
    });
}

/*
    * Gets user added paths
    * uid = User id
*/
function getUserDirs(uid) {
    return new Promise(function (resolve, reject) {
        utils.getPath(uid).then(function (data) {
            resolve(data);
        });
    });
}

/*
    * Returns items from database for all paths
    * upid = Id from basePath variable (id field from user_settings)
*/
function getUserItems(upid, types) {
    return new Promise(function (resolve, reject) {
        models.physical_items.findAll({ where: { upid: upid, type: types} }).then(function (allitems) {
            let tmplist = new items();
            allitems.map(function (obj) {
                tmplist.addItem({ path: obj.path, id: obj.id });
            });
            resolve(tmplist);
        });
    });
}

/*
    * Fills Item List array with items from users_data and returns it
*/
function fillItemList(dirs, types) {
    return new Promise(function (resolve, reject) {
        let promiseArray = Array();
        for(let i in dirs) {
            promiseArray.push(getUserItems(dirs[i].id, types));
        }

        Promise.all(promiseArray).then(function (data) {
            var itemList = new items();
            for (let i in data) {
                data[i].items.map(function (obj) {
                    itemList.addItem({ path: obj.path, id: obj.id });
                });
            }
            resolve(itemList);
        });
    });
}

/*
    * Function which checks wether the file is a video file and adds it if so
    * filename  = File name
    * itemList  = List of items in db (generated by fillItemList)
    * path      = Path of the file
    * level     = Parent id in database
    * upid      = Id of folder from users_settings
    * uid       = User id
    * udid      = Id from virtual_items row
*/
function videoCondition(filename, itemList, path, level, upid, uid, udid) {
    if (isVideo(filename)) {
        itemList.removeItem({ path: path }).catch(function (msg) {
            let tmp = pathJS.parse(filename);
            models.physical_items.create({ name: tmp.name, pid: level, type: 1, path: path, upid: upid }).then(function (createditem) {
                let newlevel = createditem.id;
                models.virtual_items.create({ uid: uid, name: tmp.name, iid: newlevel, seen: 0, deleted: 0, pid: udid, type: 1 });
                models.physical_items_mimes.create({iid: newlevel, mime: mime.lookup(filename)});
            });
        });
    }
}

/*
    * Function which checks wether the file is a subtitle file and adds it if so
    * filename  = File name
    * itemList  = List of items in db (generated by fillItemList)
    * path      = Path of the file
    * level     = Parent id in database
    * upid      = Id of folder from users_settings
    * uid       = User id
    * udid      = Id from virtual_items row
*/
function subtitleCondition(filename, itemList, path, level, upid, uid, udid) {
    if (isSubtitle(filename)) {
        itemList.removeItem({ path: path }).catch(function (msg) {
            let tmp = pathJS.parse(filename);
            models.physical_items.find({ where: {name: tmp.name, type: 1} }).then(function (data) {
                if(data === null) {
                    console.log("Video with name " + tmp.name + " not found.");
                }
                else {
                    models.physical_items.create({ name: tmp.name, pid: data.id, type: 2, path: path, upid: upid}).then(function (createdItem) {
                        models.physical_items_mimes.create({ iid: createdItem.id, mime: mime.lookup(filename)});
                    });
                }
            });
        });
    }
}

/*
    * Reads directory
    * path      = Path to directory
    * level     = Parent id in database (0 for first call)
    * itemList  = List of items in db (generated by fillItemList)
    * upid      = Id of folder from users_settings
    * uid       = User id
    * udid      = Id from user_data row
    * condition = Function which is used when checking wether the found file is the one we need
*/
function readDir(path, level, itemList, upid, uid, udid, condition) {
    var folderArray = Array();
    return new Promise(function (resolve, reject) {
        path = path.concat(pathJS.sep);
        var cycle = new Promise(function (resolve, reject) {
            fs.stat(path, function(err, stats) {
                if(err !== null) {
                    reject(err);
                }
                let data = fs.readdirSync(path);
                for (let i in data) {
                    let newPath = path.concat(data[i]);

                    try {
                        let stats = fs.statSync(newPath);
                        if (stats.isDirectory()) {
                            //TODO: make this part easier to understand
                            itemList.removeItem({ path: newPath }).then(function (msg) {
                                folderArray.push(readDir(newPath, parseInt(msg), itemList, upid, uid, udid, condition));
                            }).catch(function (msg) {
                                models.physical_items.create({ name: data[i], pid: level, type: 0, path: newPath, upid: upid }).then(function (createditem) {
                                    let newlevel = createditem.id;

                                    models.virtual_items.create({ uid: uid, name: data[i], iid: newlevel, seen: 0, deleted: 0, pid: udid, type: 0 })
                                    .then(function (createditem2) {
                                        folderArray.push(readDir(newPath, newlevel, itemList, upid, uid, createditem2.id, condition));
                                    });
                                });
                            });
                        }
                        else {
                            condition(data[i], itemList, newPath, level, upid, uid, udid);
                        }
                    } catch (err) {
                        console.log("error in readDir: " + err);
                    }
                }
                resolve(true);
            });
        });

        cycle.then(function (tmp) {
            if (folderArray.length > 0) {
                Promise.all(folderArray).then(function (data) {
                    resolve(itemList);
                }).catch(function (err) {
                    console.log(err);
                });
            } else {
                resolve(itemList);
            }
        });
    });
}
//FIXME: return correct values
/*
    * Public method to initiate scan, returns integer:
    *   -1 if failed
    *    0 if nothing was changed
    *    x number of items deleted
*/
function scan(uid, condition, types) {
    return new Promise(function (resolve, reject) {
        getUserDirs(uid).then(function (dirs) {
            fillItemList(dirs, types).then(function (itemList) {
                let promiseArray = Array();
                for(let i in dirs) {
                    promiseArray.push(readDir(dirs[i].path, 0, itemList, dirs[i].id, uid, 0, condition));
                }

                Promise.all(promiseArray).then(function (data) {
                    let ret = 0;
                    for (let i in data) {
                        if (data[i].items.length > 0) {
                            deleteMissingItems(uid, data[i]).then(function (returned) {
                                if (returned) {
                                    ret += data[i].items.length;
                                } else {
                                    reject("Failed to delete " + data[i].items.length + " items.");
                                }
                            });
                        }
                    }
                    resolve(ret);
                });
            }).catch(function (err) {
                console.log("Failed scandir: " + err);
                reject(err);
            });
        });
    });
}

/*
    * Scans for changes, updates database accordingly, returns number of items added/removed
    * uid = user id
*/
function dirscan(uid) {
    return new Promise(function (resolve, reject) {
        scan(uid, videoCondition, [0, 1]).then(function (params) {
            scan(uid, subtitleCondition, [0, 2]).then(function (params2) {
                resolve(params);
            }).catch(function (params) {
                console.log("dircan error2: " + params);
                reject(false);
            });
            //resolve(params);
            
        }).catch(function (params) {
            console.log("dirscan error: " + params);
            reject(false);
        });
    });
}

exports.dirscan = dirscan;
